1.Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k 
then left-out nodes, in the end, should remain as it is.
You may not alter the values in the list's nodes, only nodes themselves may be changed.
https://leetcode.com/problems/reverse-nodes-in-k-group/
code->int length(ListNode* head){
         ListNode* temp=head; 
         int len=0;
         while(temp!=NULL){
             temp=temp->next;
             len++;
         }
        return len;
    }
     ListNode* rev( ListNode* head, int k,int len){
         //Base case
         if(len<k){
             return head;
         }
          ListNode* curr=head;
          ListNode* pre=NULL;
          ListNode* nex=NULL;
         int count=0;
         while(curr!=NULL && count<k){
             nex=curr->next;
             curr->next=pre;
             pre=curr;
             curr=nex;
             count++;
         }
         if(nex!=NULL){
             head->next=rev(nex,k,len-k);
         }
         return pre;
         
     }
    ListNode* reverseKGroup(ListNode* head, int k) {
        int le=length(head);
        return rev(head,k,le);
    }
